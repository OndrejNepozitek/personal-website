{
    "componentChunkName": "component---src-templates-blog-post-blog-post-tsx",
    "path": "/1-graph-based-dungeon-generator-basics/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"mdx":{"id":"be55ca0c-7cf0-5bbd-95d0-0d9a396119c9","excerpt":"In this blog post, I’ll describe an algorithm for procedural generation of 2D dungeon levels with a predefined structure. I won’t go into implementation details…","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"date\": \"2018-12-23\",\n  \"title\": \"Graph-Based Dungeon Generator: Basics\",\n  \"series\": \"graph-based-generator\",\n  \"seriesName\": \"Basics\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar BlogSeries = makeShortcode(\"BlogSeries\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In this blog post, I\\u2019ll describe an algorithm for procedural generation of 2D dungeon levels with a predefined structure. I won\\u2019t go into implementation details today as I plan to make this into a (mini) series and cover it in the next post.\"), mdx(BlogSeries, {\n    slug: props.slug,\n    mdxType: \"BlogSeries\"\n  }), mdx(\"h2\", null, \"Background\"), mdx(\"p\", null, \"The algorithm was written as a part of my \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/OndrejNepozitek/Edgar-DotNet/blob/text/bachelor_thesis.pdf\"\n  }, \"bachelor thesis\"), \" and is based on the previous work from Ma et al (2014). The goal of the thesis was to improve the speed of the algorithm and enhance it with new features. I\\u2019m quite satisfied with the result as we were able to make the algorithm fast enough to be used during game runtime. After finishing the thesis, we decided to transform it into a paper and submit it to the Game-ON 2018 conference.\"), mdx(\"h2\", null, \"Algorithm\"), mdx(\"p\", null, \"To produce a game level, the algorithm takes a set of polygonal building blocks and a level connectivity graph (the level topology) as an input. Nodes in the graph represent rooms, and edges define connectivities between them. The goal of the algorithm is to assign a room shape and a position to each node in the graph in a way that no two room shapes intersect and every pair of neighbouring room shapes can be connected by doors.\"), mdx(\"p\", null, \"Through the connectivity graph, a game designer can easily affect the flow of gameplay. Do you want a single main path to a boss room with some optional side paths? Simply start with a path graph and then pick some nodes where the player can choose to either follow the main path or explore a side path with possible treasures and/or monsters waiting for him. Do you want a shortcut? Simply choose two nodes in the graph and add a shorter path that connects them. The possibilities are endless.\"), mdx(\"p\", null, \"Not only does the algorithm allow game designers to control the high-level structure of generated layouts, it also provides ways to control the look of individual rooms and how they are connected to each other.\"), mdx(\"h2\", null, \"Different room shapes for different rooms\"), mdx(\"p\", null, \"I mentioned having a boos room at the end of the dungeon. But we do not want our boss room to look like every other room, right? The algorithm supports defining room shapes on a per-room basis. For example, we may have a spawn room and a boss room that should have their own sets of room shapes and then one generic set for other rooms.\"));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"slug":"/1-graph-based-dungeon-generator-basics/"},"frontmatter":{"title":"Graph-Based Dungeon Generator: Basics","date":"December 23, 2018","description":null}},"previous":null,"next":{"fields":{"slug":"/3-unity-2d-dungeon-generator/"},"frontmatter":{"title":"Unity 2D Dungeon Generator"}}},"pageContext":{"id":"be55ca0c-7cf0-5bbd-95d0-0d9a396119c9","previousPostId":null,"nextPostId":"96cc438f-d860-5b03-a633-2c209f9319b0"}},
    "staticQueryHashes": ["2447914076","323856243"]}